# Cat Righting Reflex Simulation: A Quaternion Approach
**Visualizing Zero-Angular Momentum Rotation using Python & Matplotlib**

**Author:** Ada Tsan Qin  
**Date:** December 2025

---

## 1. Introduction

### Motivation
The primary motivation behind this project is to **demonstrate the practical application of Quaternions in simulating complex, compound 3D rotations**.

While the "Cat Righting Reflex" is a classic physics problem often described using Euler angles, implementing it via Quaternions offers distinct advantages in avoiding Gimbal Lock and simplifying the composition of rotations (e.g., combining a global spine bending with a local body twisting).

### AI-Aided Development
This project adopts an **AI-Aided Software Engineering (AIASE)** workflow. The core implementation was generated by transforming high-level logical pseudo-code into executable Python code, demonstrating how abstract algorithmic thought can be rapidly translated into visualization tools.

---

## 2. Physics of the Cat Righting Reflex

The "falling cat problem" explains how a cat, dropped upside down with no net angular momentum ($L=0$), can reorient itself to land on its feet without violating conservation laws.

### The Mechanism (Kane's Model)
The cat acts as a non-rigid body consisting of two cylinders (front and back) connected by a flexible spine. The reorientation is achieved through a sequence of shape changes and internal twists, as illustrated below.

![Cat Falling Sequence](cat-falling.png)
*Figure 1: Photographic sequence and mechanical model of a falling cat performing the righting reflex.*

1.  **Bend**: The cat bends its spine, changing the relative axes of the front and back sections.
2.  **Twist with Inertia Manipulation**:
    * The cat pulls in its front legs (reducing Moment of Inertia, $I_{front}$) and extends its back legs (increasing $I_{back}$).
    * It rotates the front body by a large angle. To conserve $L=0$, the back body rotates in the opposite direction but by a much smaller angle.
3.  **Swap & Repeat**: The cat extends front legs and pulls in back legs, then repeats the twist logic for the back body.
4.  **Unbend**: The cat straightens its spine, now facing downwards.

**Key Equation:**
$$I_{front} \cdot \omega_{front} + I_{back} \cdot \omega_{back} = 0$$
Therefore, the passive rotation is:
$$\Delta \theta_{passive} = -\frac{I_{active}}{I_{passive}} \cdot \Delta \theta_{active}$$

---

## 3. Physical Model Implementation

To ensure visual clarity and avoid the "Kinetic Depth Effect" (optical illusion of reverse rotation), this simulation uses a specific geometric setup:

* **Geometry**: Two **Square Prisms** (instead of cylinders). The flat surfaces and edges provide unambiguous visual cues for rotation direction.
* **Connection**: A thick black line represents the **Spine**, connecting the two halves.
* **Separation**: A gap is introduced between the two halves to visualize the spine bending clearly.
* **Dynamics**: The prisms visually expand (extend legs) or shrink (retract legs) to represent the changing Moment of Inertia ($I$) during the animation phases.

---

## 4. Application of Quaternions

Instead of complex Euler angle rotation matrices, this project utilizes **Quaternions** for robust geometric transformations. The total rotation $q_{total}$ for each body segment is a composition of two distinct rotations:

1.  **Twist ($q_{twist}$)**: Rotation around the body's local longitudinal axis (Rolling).
2.  **Bend ($q_{bend}$)**: Rotation around the global vertical axis (Yawing/Bending).

The final orientation is calculated via quaternion multiplication:
$$q_{total} = q_{bend} \otimes q_{twist}$$

This approach ensures that the "bending" of the spine and the "twisting" of the body are mathematically decoupled yet applied seamlessly.

---

## 5. Algorithmic Logic (Pseudo-code Source)

The Python initial implementation follows this logical blueprint:

```text
FUNCTION Main():
    // Phase A: Bend Spine
    FOR frame IN bending_phase:
        SpineAngle = Interpolate(0 -> 90°)

    // Phase B: Front Twist (Front contracts, Back extends)
    SET Inertia_Front = LOW, Inertia_Back = HIGH
    FOR frame IN twist_phase_1:
        Front_Angle += Large_Step
        Back_Angle  += -(Inertia_Front / Inertia_Back) * Large_Step

    // Phase C: Back Twist (Front extends, Back contracts)
    SET Inertia_Front = HIGH, Inertia_Back = LOW
    FOR frame IN twist_phase_2:
        Back_Angle  += Large_Step
        Front_Angle += -(Inertia_Back / Inertia_Front) * Large_Step

    // Phase D: Re-alignment
    FOR frame IN unbending_phase:
        SpineAngle = Interpolate(90° -> 0°)
        
    RENDER(Scene)
```
The animition and detailed rendering are completed by Gemini 3, with error correction and fine tunes by hand.

---

## 6. Code Structure

The script `cat_reflex_quaternion.py` is organized as follows:

* **1. Configuration**:
    * Sets up physics constants ($I_0$, ratios), timing (frames), and `matplotlib` styling.
* **2. Geometry Helpers**:
    * `generate_square_beam`: Generates vertex data for the square prisms.
    * `apply_quaternion_transform`: Uses `scipy.spatial.transform.Rotation` to apply $q_{bend} \otimes q_{twist}$ to point clouds.
* **3. Animation Logic (`update` function)**:
    * Acts as a state machine processing Phases A, B, C, and D.
    * Calculates real-time angular momentum conservation.
    * Updates the 3D visualization and the 2D data plot.
* **4. Visualization**:
    * **3D Plot**: Uses Perspective Projection (`ax.set_proj_type('persp')`) and Light Source Shading to render the bodies.
    * **2D Plot**: Tracks $L_{front}$, $L_{back}$, and $L_{total}$ over time.

---

## 7. Execution Results

The following GIF demonstrates the simulation of the cat righting reflex. The animation shows the cat bending its spine, twisting its body segments while conserving angular momentum, and finally straightening its spine to land on its feet.

![Cat Righting Reflex Simulation](cat_reflex.gif)

---

## 8. Usage

### Dependencies
Ensure you have a Python 3 environment with the following libraries:
```bash
pip install numpy matplotlib scipy
```

### Running the Simulation
```bash
python cat_reflex_quaternion.py
```
The script will display the animation window and automatically save the result as `cat_reflex_final.gif`.

### Customization
You can modify the `ratio_shrink` and `ratio_expand` variables in the code to test how different mass distributions affect the rotation efficiency.